---
# Godon Optimization Configuration
#
# This configuration defines Linux kernel/networking parameter optimization for
# minimizing latency and maximizing throughput while maintaining system safety.
#
# DESIGN NOTES:
# - No 'type' field on parameters: breeder knows parameter types internally
# - Multiple disjoint ranges enable parallel workers to explore different regions
# - Objectives = what we optimize (multi-objective Pareto optimization)
# - Guardrails = safety limits (trigger rollback if exceeded)
# - Separate breeders for different target classes (avoids per-target complexity)
#
# Config format version - independent from godon software version
meta:
  configVersion: "0.3"

# Breeder worker configuration
breeder:
  type: "linux_performance"  # Which breeder worker implementation to use

# ============================================================================
# PARAMETER SEARCH SPACE
# ============================================================================
# Define the Linux tuning knobs to optimize. Each parameter type (sysctl, sysfs,
# cpufreq, ethtool) represents a different mechanism for modifying system behavior.
#
# Parameter types are inferred by the breeder from its internal registry - no
# 'type' field needed in config. This keeps the config clean and avoids errors.
#
# Multiple disjoint ranges (e.g., tcp_rmem with conservative and performance
# ranges) allow parallel workers to explore different regions of the search space
# simultaneously, accelerating discovery of optimal configurations.
# ============================================================================
settings:
  # System Control (proc/sys) - key-value parameters
  sysctl:
    # TCP read buffer sizes - multiple disjoint ranges for parallel exploration
    net.ipv4.tcp_rmem:
      constraints:
        - {step: 100, lower: 4096, upper: 131072}     # Conservative
        - {step: 100, lower: 262144, upper: 6291456}   # Performance

    # TCP write buffer sizes
    net.ipv4.tcp_wmem:
      constraints:
        - {step: 100, lower: 4096, upper: 6291456}

    # Network device budget - conservative vs aggressive
    net.core.netdev_budget:
      constraints:
        - {step: 10, lower: 10, upper: 100}
        - {step: 10, lower: 500, upper: 2000}

    # Maximum backlog queue length - disjoint ranges
    net.core.netdev_max_backlog:
      constraints:
        - {step: 10, lower: 10, upper: 1000}
        - {step: 10, lower: 3000, upper: 5000}

    # CPU weight for network device processing
    net.core.dev_weight:
      constraints:
        - {step: 10, lower: 10, upper: 2000}

  # System Filesystem (sysfs) - use aliases for long paths
  sysfs:
    # CPU frequency scaling governor
    cpu_governor:
      path: "/devices/system/cpu/cpu0/cpufreq/scaling_governor"
      constraints:
        values: ["performance", "powersave", "ondemand"]

    # Transparent huge pages
    transparent_hugepage:
      path: "/sys/kernel/mm/transparent_hugepage/enabled"
      constraints:
        values: ["always", "madvise", "never"]

    # Network interface queue discipline
    qdisc:
      path: "/sys/class/net/eth0/queue/disc"
      constraints:
        values: ["fq", "pfifo_fast", "htb"]

  # CPU Frequency Scaling - structured config
  cpufreq:
    governor:
      constraints:
        values: ["performance", "powersave", "ondemand", "schedutil"]

    min_freq_ghz:
      constraints:
        - {step: 0.2, lower: 1.2, upper: 2.4}

    max_freq_ghz:
      constraints:
        - {step: 0.2, lower: 2.4, upper: 4.8}

  # Network Interface (ethtool) - structured config
  ethtool:
    eth0:
      # TCP Segmentation Offload
      tso:
        constraints:
          values: ["on", "off"]

      # Generic Receive Offload
      gro:
        constraints:
          values: ["on", "off"]

      # RX ring buffer size
      rx_ring:
        constraints:
          - {step: 512, lower: 512, upper: 8192}

      # TX ring buffer size
      tx_ring:
        constraints:
          - {step: 512, lower: 512, upper: 8192}

# Execution control
run:
  parallel: 3  # Number of parallel workers

  completion_criteria:
    iterations:
      min: 10  # Minimum trials before considering early stopping
      max: 1000  # Maximum trials before forcing termination
    timing:
      end: "7d"  # Maximum lifetime of the optimization run (e.g., 7d, 24h, 60m)
    quality_achieved: true  # Stop when all quality_threshold objectives are met

cooperation:
  active: true  # Enable shared learning between parallel workers

  # Sharing strategy: "probabilistic", "best", "worst", "extremes"
  share_strategy: "extremes"

  # Quality-based filtering parameters
  top_percentile: 0.2  # Share top 20% of trials
  bottom_percentile: 0.2  # Share bottom 20% of trials
  min_trials_for_filtering: 10  # Wait for 10 trials before quality filtering kicks in

  # Legacy probabilistic sharing
  probability: 0.8  # 80% chance to share each trial

# ============================================================================
# OPTIMIZATION OBJECTIVES
# ============================================================================
# Define what we want to optimize. Multiple objectives are optimized simultaneously
# using Pareto efficiency - the breeder finds the Pareto frontier of optimal
# tradeoffs between competing objectives (e.g., low latency vs high throughput).
#
# IMPORTANT: Objectives are NOT used for rollback. If a trial is worse in one
# objective but better in another, it may still be kept on the Pareto frontier.
# Rollback is only triggered by guardrails (see below).
# ============================================================================
objectives:
  - name: "tcp_rtt"
    direction: minimize  # Minimize round-trip time
    quality_threshold: 50  # Stop when RTT <= 50ms (optional)
    reconnaissance:
      service: prometheus  # Metric source type
      query: "scalar(tcp_rtt * 1000)"  # Prometheus query (converts to milliseconds)
      stabilization_seconds: 10  # Wait period after parameter change before sampling
      samples: 5  # Number of samples to collect
      interval: 2  # Seconds between samples

  - name: "tcp_delivery_rate_bytes"
    direction: maximize  # Maximize delivery rate (throughput)
    quality_threshold: 1048576  # Stop when throughput >= 1MB/s (optional)
    reconnaissance:
      service: prometheus
      query: "scalar(rate(tcp_delivery_rate_bytes[1m]))"
      stabilization_seconds: 10
      samples: 5
      interval: 2

# ============================================================================
# ROLLBACK STRATEGIES
# ============================================================================
# Define reusable rollback configurations. Strategies are referenced by targets
# using the rollback.strategy field. This allows multiple targets to share the
# same rollback behavior while maintaining per-target enablement control.
#
# Rollback is ONLY triggered by guardrails (see below), not by objectives.
# The multi-objective optimization (Pareto frontier) is handled by Optuna.
# ============================================================================
rollback_strategies:
  standard:
    consecutive_failures: 3  # Avoid false positives from transient spikes
    target_state: "previous"  # previous | best | baseline
    max_attempts: 3  # Retry rollback if it fails

    # What to do if rollback fails after all attempts:
    # - stop: Halt the entire optimization run
    # - continue: Keep trying trials (including with the failed target)
    # - skip_target: Mark failed target as unhealthy, continue with other targets
    on_failure: "stop"
    timeout_seconds: 60  # Maximum time to complete rollback
    after:
      action: "pause"  # pause | continue | stop
      duration: 300  # Required if action=pause: wait seconds before resuming

# ============================================================================
# SAFETY GUARDRAILS
# ============================================================================
# Define safety limits that trigger automatic rollback if exceeded. Unlike
# objectives (which we optimize), guardrails are constraints that must NOT be
# violated.
#
# Key difference from objectives:
# - Objectives: Multi-objective Pareto optimization (tradeoffs allowed)
# - Guardrails: Binary safety limits (rollback immediately if exceeded)
#
# Example: We want to minimize RTT (objective) while keeping CPU < 90% (guardrail).
# If RTT improves but CPU hits 95%, we rollback - system safety comes first.
# ============================================================================
guardrails:
  - name: "cpu_usage"
    hard_limit: 90  # Rollback if CPU usage exceeds 90%
    reconnaissance:
      service: prometheus
      query: "avg(rate(process_cpu_seconds_total[5m])) * 100"
      stabilization_seconds: 10
      samples: 3
      interval: 2

  - name: "system_errors"
    hard_limit: 10  # Rollback if system errors exceed 10 per minute
    reconnaissance:
      service: prometheus
      query: "rate(kernel_errors_total[1m])"
      stabilization_seconds: 10
      samples: 3
      interval: 2

# Parameter application (effectuation) configuration
effectuation:
  targets:
    - type: "ssh"  # Target type (must match breeder's supported types)
      id: "target_1"
      address: "10.0.5.53"  # Target system IP address
      username: "godon_robot"
      credentialName: "godon_ssh_key"  # Credential name from credential catalog
      # Alternatively, use credentialId to reference by UUID:
      # credentialId: "123e4567-e89b-12d3-a456-426614174000"
      allows_downtime: false  # Target cannot be unavailable (production-safe tuning only)
      rollback:
        enabled: true  # Enable automatic rollback on guardrail violations
        strategy: "standard"  # Reference to rollback_strategies section

    - type: "ssh"  # Target type (must match breeder's supported types)
      id: "target_2"
      address: "10.0.5.54"  # Target system IP address
      username: "godon_robot"
      credentialName: "godon_ssh_key"  # Credential name from credential catalog
      # Alternatively, use credentialId to reference by UUID:
      # credentialId: "123e4567-e89b-12d3-a456-426614174000"
      allows_downtime: false  # Target cannot be unavailable (production-safe tuning only)
      rollback:
        enabled: true  # Enable automatic rollback on guardrail violations
        strategy: "standard"  # Reference to rollback_strategies section
